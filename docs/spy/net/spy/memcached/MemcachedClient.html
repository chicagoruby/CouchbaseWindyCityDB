<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_29) on Wed Mar 21 17:56:33 PDT 2012 -->
<TITLE>
MemcachedClient (spymemcached 2.8.1 API)
</TITLE>

<META NAME="date" CONTENT="2012-03-21">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MemcachedClient (spymemcached 2.8.1 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MemcachedClient.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/spy/memcached/KeyUtil.html" title="class in net.spy.memcached"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/spy/memcached/MemcachedClient.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MemcachedClient.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.spy.memcached</FONT>
<BR>
Class MemcachedClient</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../net/spy/memcached/compat/SpyObject.html" title="class in net.spy.memcached.compat">net.spy.memcached.compat.SpyObject</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>net.spy.memcached.MemcachedClient</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>, <A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>MemcachedClient</B><DT>extends <A HREF="../../../net/spy/memcached/compat/SpyObject.html" title="class in net.spy.memcached.compat">SpyObject</A><DT>implements <A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A>, <A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A></DL>
</PRE>

<P>
Client to a memcached server.

 <h2>Basic usage</h2>

 <pre>
 MemcachedClient c = new MemcachedClient(
    new InetSocketAddress(&quot;hostname&quot;, portNum));

 // Store a value (async) for one hour
 c.set(&quot;someKey&quot;, 3600, someObject);
 // Retrieve a value.
 Object myObject = c.get(&quot;someKey&quot;);
 </pre>

 <h2>Advanced Usage</h2>

 <p>
 MemcachedClient may be processing a great deal of asynchronous messages or
 possibly dealing with an unreachable memcached, which may delay processing.
 If a memcached is disabled, for example, MemcachedConnection will continue to
 attempt to reconnect and replay pending operations until it comes back up. To
 prevent this from causing your application to hang, you can use one of the
 asynchronous mechanisms to time out a request and cancel the operation to the
 server.
 </p>

 <pre>
      // Get a memcached client connected to several servers
      // over the binary protocol
      MemcachedClient c = new MemcachedClient(new BinaryConnectionFactory(),
              AddrUtil.getAddresses("server1:11211 server2:11211"));

      // Try to get a value, for up to 5 seconds, and cancel if it
      // doesn't return
      Object myObj = null;
      Future&lt;Object&gt; f = c.asyncGet("someKey");
      try {
          myObj = f.get(5, TimeUnit.SECONDS);
      // throws expecting InterruptedException, ExecutionException
      // or TimeoutException
      } catch (Exception e) {  /*  /
          // Since we don't need this, go ahead and cancel the operation.
          // This is not strictly necessary, but it'll save some work on
          // the server.  It is okay to cancel it if running.
          f.cancel(true);
          // Do other timeout related stuff
      }
 </pre>
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/auth/AuthDescriptor.html" title="class in net.spy.memcached.auth">AuthDescriptor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#authDescriptor">authDescriptor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/auth/AuthThreadMonitor.html" title="class in net.spy.memcached.auth">AuthThreadMonitor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#authMonitor">authMonitor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#connFactory">connFactory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/MemcachedConnection.html" title="class in net.spy.memcached">MemcachedConnection</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#mconn">mconn</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#operationTimeout">operationTimeout</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/OperationFactory.html" title="interface in net.spy.memcached">OperationFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#opFact">opFact</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#shuttingDown">shuttingDown</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/transcoders/TranscodeService.html" title="class in net.spy.memcached.transcoders">TranscodeService</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#tcService">tcService</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#transcoder">transcoder</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.spy.memcached.MemcachedClientIF"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface net.spy.memcached.<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#MAX_KEY_LENGTH">MAX_KEY_LENGTH</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(net.spy.memcached.ConnectionFactory, java.util.List)">MemcachedClient</A></B>(<A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A>&nbsp;cf,
                java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client over the specified memcached locations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(java.net.InetSocketAddress...)">MemcachedClient</A></B>(java.net.InetSocketAddress...&nbsp;ia)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client operating on the specified memcached locations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(java.util.List)">MemcachedClient</A></B>(java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client over the specified memcached locations.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#add(java.lang.String, int, java.lang.Object)">add</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an object to the cache (using the default transcoder) iff it does not
 exist already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">add</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    T&nbsp;o,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an object to the cache iff it does not exist already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#addObserver(net.spy.memcached.ConnectionObserver)">addObserver</A></B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a connection observer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#append(long, java.lang.String, java.lang.Object)">append</A></B>(long&nbsp;cas,
       java.lang.String&nbsp;key,
       java.lang.Object&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">append</A></B>(long&nbsp;cas,
       java.lang.String&nbsp;key,
       T&nbsp;val,
       <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         int&nbsp;exp,
         T&nbsp;value,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, java.lang.Object)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         T&nbsp;value,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncDecr(java.lang.String, int)">asyncDecr</A></B>(java.lang.String&nbsp;key,
          int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous decrement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncDecr(java.lang.String, long)">asyncDecr</A></B>(java.lang.String&nbsp;key,
          long&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous decrement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/GetFuture.html" title="class in net.spy.memcached.internal">GetFuture</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGet(java.lang.String)">asyncGet</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key asynchronously and decode with the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/GetFuture.html" title="class in net.spy.memcached.internal">GetFuture</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGet</A></B>(java.lang.String&nbsp;key,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetAndTouch(java.lang.String, int)">asyncGetAndTouch</A></B>(java.lang.String&nbsp;key,
                 int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key to reset its expiration time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">asyncGetAndTouch</A></B>(java.lang.String&nbsp;key,
                 int&nbsp;exp,
                 <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key to reset its expiration time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Collection)">asyncGetBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache and decode them with
 the given transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Collection, java.util.Iterator)">asyncGetBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
             java.util.Iterator&lt;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&gt;&nbsp;tcIter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Iterator)">asyncGetBulk</A></B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache and decode them with
 the given transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Iterator, java.util.Iterator)">asyncGetBulk</A></B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
             java.util.Iterator&lt;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&gt;&nbsp;tcIter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.lang.String...)">asyncGetBulk</A></B>(java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Varargs wrapper for asynchronous bulk gets with the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">asyncGetBulk</A></B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
             java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Varargs wrapper for asynchronous bulk gets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGets(java.lang.String)">asyncGets</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) the given key asynchronously and decode using the
 default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGets</A></B>(java.lang.String&nbsp;key,
          <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) the given key asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncIncr(java.lang.String, int)">asyncIncr</A></B>(java.lang.String&nbsp;key,
          int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asychronous increment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncIncr(java.lang.String, long)">asyncIncr</A></B>(java.lang.String&nbsp;key,
          long&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asychronous increment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    int&nbsp;exp,
    T&nbsp;value,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, java.lang.Object)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation with the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    T&nbsp;value,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#connectionEstablished(java.net.SocketAddress, int)">connectionEstablished</A></B>(java.net.SocketAddress&nbsp;sa,
                      int&nbsp;reconnectCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A connection has just successfully been established on the given socket.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#connectionLost(java.net.SocketAddress)">connectionLost</A></B>(java.net.SocketAddress&nbsp;sa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A connection was just lost on the given socket.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given key by the given value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int, long)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int, long, int)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, long)">decr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given key by the given value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, long, long)">decr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, long, long, int)">decr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#delete(java.lang.String)">delete</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete the given key from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#delete(java.lang.String, int)">delete</A></B>(java.lang.String&nbsp;key,
       int&nbsp;hold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Hold values are no longer honored.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#flush()">flush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flush all caches from all servers immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#flush(int)">flush</A></B>(int&nbsp;delay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flush all caches from all servers with a delay of application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#get(java.lang.String)">get</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get with a single key and decode using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#get(java.lang.String, net.spy.memcached.transcoders.Transcoder)">get</A></B>(java.lang.String&nbsp;key,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get with a single key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getAndTouch(java.lang.String, int)">getAndTouch</A></B>(java.lang.String&nbsp;key,
            int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a single key and reset its expiration using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">getAndTouch</A></B>(java.lang.String&nbsp;key,
            int&nbsp;exp,
            <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get with a single key and reset its expiration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection&lt;java.net.SocketAddress&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getAvailableServers()">getAvailableServers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the addresses of available servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Collection)">getBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Map&lt;java.lang.String,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">getBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Iterator)">getBulk</A></B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Map&lt;java.lang.String,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)">getBulk</A></B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.lang.String...)">getBulk</A></B>(java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Map&lt;java.lang.String,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">getBulk</A></B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
        java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/NodeLocator.html" title="interface in net.spy.memcached">NodeLocator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getNodeLocator()">getNodeLocator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a read-only wrapper around the node locator wrapping this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#gets(java.lang.String)">gets</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) with a single key using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">gets</A></B>(java.lang.String&nbsp;key,
     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) with a single key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getStats()">getStats</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all of the stats from all of the connections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getStats(java.lang.String)">getStats</A></B>(java.lang.String&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a set of stats from all connections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getTranscoder()">getTranscoder</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the default transcoder that's in use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection&lt;java.net.SocketAddress&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getUnavailableServers()">getUnavailableServers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the addresses of unavailable servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getVersions()">getVersions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the versions of all of the connected memcacheds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given key by the given amount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int, long)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int, long, int)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, long)">incr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given key by the given amount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, long, long)">incr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, long, long, int)">incr</A></B>(java.lang.String&nbsp;key,
     long&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#listSaslMechanisms()">listSaslMechanisms</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of SASL mechanisms supported by the servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#prepend(long, java.lang.String, java.lang.Object)">prepend</A></B>(long&nbsp;cas,
        java.lang.String&nbsp;key,
        java.lang.Object&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepend to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">prepend</A></B>(long&nbsp;cas,
        java.lang.String&nbsp;key,
        T&nbsp;val,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepend to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#removeObserver(net.spy.memcached.ConnectionObserver)">removeObserver</A></B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove a connection observer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#replace(java.lang.String, int, java.lang.Object)">replace</A></B>(java.lang.String&nbsp;key,
        int&nbsp;exp,
        java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace an object with the given value (transcoded with the default
 transcoder) iff there is already a value for the given key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">replace</A></B>(java.lang.String&nbsp;key,
        int&nbsp;exp,
        T&nbsp;o,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace an object with the given value iff there is already a value for the
 given key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#set(java.lang.String, int, java.lang.Object)">set</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set an object in the cache (using the default transcoder) regardless of any
 existing value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">set</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    T&nbsp;o,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set an object in the cache regardless of any existing value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shut down immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#shutdown(long, java.util.concurrent.TimeUnit)">shutdown</A></B>(long&nbsp;timeout,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shut down this client gracefully.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#touch(java.lang.String, int)">touch</A></B>(java.lang.String&nbsp;key,
      int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Touch the given key to reset its expiration time with the default
 transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#touch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">touch</A></B>(java.lang.String&nbsp;key,
      int&nbsp;exp,
      <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Touch the given key to reset its expiration time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#waitForQueues(long, java.util.concurrent.TimeUnit)">waitForQueues</A></B>(long&nbsp;timeout,
              java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for the queues to die down.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.spy.memcached.compat.SpyObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class net.spy.memcached.compat.<A HREF="../../../net/spy/memcached/compat/SpyObject.html" title="class in net.spy.memcached.compat">SpyObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/spy/memcached/compat/SpyObject.html#getLogger()">getLogger</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="shuttingDown"><!-- --></A><H3>
shuttingDown</H3>
<PRE>
protected volatile boolean <B>shuttingDown</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="operationTimeout"><!-- --></A><H3>
operationTimeout</H3>
<PRE>
protected final long <B>operationTimeout</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mconn"><!-- --></A><H3>
mconn</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/MemcachedConnection.html" title="class in net.spy.memcached">MemcachedConnection</A> <B>mconn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="opFact"><!-- --></A><H3>
opFact</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/OperationFactory.html" title="interface in net.spy.memcached">OperationFactory</A> <B>opFact</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="transcoder"><!-- --></A><H3>
transcoder</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt; <B>transcoder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="tcService"><!-- --></A><H3>
tcService</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/transcoders/TranscodeService.html" title="class in net.spy.memcached.transcoders">TranscodeService</A> <B>tcService</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="authDescriptor"><!-- --></A><H3>
authDescriptor</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/auth/AuthDescriptor.html" title="class in net.spy.memcached.auth">AuthDescriptor</A> <B>authDescriptor</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="connFactory"><!-- --></A><H3>
connFactory</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A> <B>connFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="authMonitor"><!-- --></A><H3>
authMonitor</H3>
<PRE>
protected final <A HREF="../../../net/spy/memcached/auth/AuthThreadMonitor.html" title="class in net.spy.memcached.auth">AuthThreadMonitor</A> <B>authMonitor</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MemcachedClient(java.net.InetSocketAddress...)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(java.net.InetSocketAddress...&nbsp;ia)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client operating on the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>ia</CODE> - the memcached locations
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>
<HR>

<A NAME="MemcachedClient(java.util.List)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client over the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>addrs</CODE> - the socket addrs
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>
<HR>

<A NAME="MemcachedClient(net.spy.memcached.ConnectionFactory, java.util.List)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(<A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A>&nbsp;cf,
                       java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client over the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>cf</CODE> - the connection factory to configure connections for this client<DD><CODE>addrs</CODE> - the socket addresses
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getAvailableServers()"><!-- --></A><H3>
getAvailableServers</H3>
<PRE>
public java.util.Collection&lt;java.net.SocketAddress&gt; <B>getAvailableServers</B>()</PRE>
<DL>
<DD>Get the addresses of available servers.

 <p>
 This is based on a snapshot in time so shouldn't be considered completely
 accurate, but is a useful for getting a feel for what's working and what's
 not working.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getAvailableServers()">getAvailableServers</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>point-in-time view of currently available servers</DL>
</DD>
</DL>
<HR>

<A NAME="getUnavailableServers()"><!-- --></A><H3>
getUnavailableServers</H3>
<PRE>
public java.util.Collection&lt;java.net.SocketAddress&gt; <B>getUnavailableServers</B>()</PRE>
<DL>
<DD>Get the addresses of unavailable servers.

 <p>
 This is based on a snapshot in time so shouldn't be considered completely
 accurate, but is a useful for getting a feel for what's working and what's
 not working.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getUnavailableServers()">getUnavailableServers</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>point-in-time view of currently available servers</DL>
</DD>
</DL>
<HR>

<A NAME="getNodeLocator()"><!-- --></A><H3>
getNodeLocator</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/NodeLocator.html" title="interface in net.spy.memcached">NodeLocator</A> <B>getNodeLocator</B>()</PRE>
<DL>
<DD>Get a read-only wrapper around the node locator wrapping this instance.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getNodeLocator()">getNodeLocator</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>this instance's NodeLocator</DL>
</DD>
</DL>
<HR>

<A NAME="getTranscoder()"><!-- --></A><H3>
getTranscoder</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt; <B>getTranscoder</B>()</PRE>
<DL>
<DD>Get the default transcoder that's in use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getTranscoder()">getTranscoder</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>this instance's Transcoder</DL>
</DD>
</DL>
<HR>

<A NAME="touch(java.lang.String, int)"><!-- --></A><H3>
touch</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>touch</B>(java.lang.String&nbsp;key,
                                                    int&nbsp;exp)</PRE>
<DL>
<DD>Touch the given key to reset its expiration time with the default
 transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#touch(java.lang.String, int)">touch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>exp</CODE> - the new expiration to set for the given key
<DT><B>Returns:</B><DD>a future that will hold the return value of whether or not the
         fetch succeeded
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="touch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
touch</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>touch</B>(java.lang.String&nbsp;key,
                                                    int&nbsp;exp,
                                                    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Touch the given key to reset its expiration time.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#touch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">touch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>exp</CODE> - the new expiration to set for the given key<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of whether or not the
         fetch succeeded
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="append(long, java.lang.String, java.lang.Object)"><!-- --></A><H3>
append</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>append</B>(long&nbsp;cas,
                                                 java.lang.String&nbsp;key,
                                                 java.lang.Object&nbsp;val)</PRE>
<DL>
<DD>Append to an existing value in the cache.

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#append(long, java.lang.String, java.lang.Object)">append</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be appended<DD><CODE>val</CODE> - the value to append
<DT><B>Returns:</B><DD>a future indicating success, false if there was no change to the
         value
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="append(long,java.lang.String,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
append</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>append</B>(long&nbsp;cas,
                                                     java.lang.String&nbsp;key,
                                                     T&nbsp;val,
                                                     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Append to an existing value in the cache.

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">append</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be appended<DD><CODE>val</CODE> - the value to append<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="prepend(long, java.lang.String, java.lang.Object)"><!-- --></A><H3>
prepend</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>prepend</B>(long&nbsp;cas,
                                                  java.lang.String&nbsp;key,
                                                  java.lang.Object&nbsp;val)</PRE>
<DL>
<DD>Prepend to an existing value in the cache.

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#prepend(long, java.lang.String, java.lang.Object)">prepend</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be prepended<DD><CODE>val</CODE> - the value to append
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="prepend(long,java.lang.String,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
prepend</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>prepend</B>(long&nbsp;cas,
                                                      java.lang.String&nbsp;key,
                                                      T&nbsp;val,
                                                      <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Prepend to an existing value in the cache.

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">prepend</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be prepended<DD><CODE>val</CODE> - the value to append<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String,long,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                             long&nbsp;casId,
                                                             T&nbsp;value,
                                                             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronous CAS operation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String,long,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="asyncCAS(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                             long&nbsp;casId,
                                                             int&nbsp;exp,
                                                             T&nbsp;value,
                                                             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronous CAS operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String, long, java.lang.Object)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                         long&nbsp;casId,
                                                         java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Asynchronous CAS operation using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncCAS(java.lang.String, long, java.lang.Object)">asyncCAS</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String,long,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="cas(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
cas</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                           long&nbsp;casId,
                           T&nbsp;value,
                           <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Perform a synchronous CAS operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String,long,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="cas(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
cas</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                           long&nbsp;casId,
                           int&nbsp;exp,
                           T&nbsp;value,
                           <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Perform a synchronous CAS operation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#cas(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)">cas</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String, long, java.lang.Object)"><!-- --></A><H3>
cas</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                       long&nbsp;casId,
                       java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Perform a synchronous CAS operation with the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#cas(java.lang.String, long, java.lang.Object)">cas</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
add</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>add</B>(java.lang.String&nbsp;key,
                                                  int&nbsp;exp,
                                                  T&nbsp;o,
                                                  <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Add an object to the cache iff it does not exist already.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">add</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>add</B>(java.lang.String&nbsp;key,
                                              int&nbsp;exp,
                                              java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Add an object to the cache (using the default transcoder) iff it does not
 exist already.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#add(java.lang.String, int, java.lang.Object)">add</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
set</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>set</B>(java.lang.String&nbsp;key,
                                                  int&nbsp;exp,
                                                  T&nbsp;o,
                                                  <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Set an object in the cache regardless of any existing value.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">set</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
set</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>set</B>(java.lang.String&nbsp;key,
                                              int&nbsp;exp,
                                              java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Set an object in the cache (using the default transcoder) regardless of any
 existing value.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#set(java.lang.String, int, java.lang.Object)">set</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="replace(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
replace</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>replace</B>(java.lang.String&nbsp;key,
                                                      int&nbsp;exp,
                                                      T&nbsp;o,
                                                      <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Replace an object with the given value iff there is already a value for the
 given key.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">replace</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="replace(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
replace</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>replace</B>(java.lang.String&nbsp;key,
                                                  int&nbsp;exp,
                                                  java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Replace an object with the given value (transcoded with the default
 transcoder) iff there is already a value for the given key.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as given,
 and will be processed per the memcached protocol specification:
 </p>

 <p>
 Note that the return will be false any time a mutation has not occurred.
 </p>

 <blockquote>
 <p>
 The actual value sent may either be Unix time (number of seconds since
 January 1, 1970, as a 32-bit value), or a number of seconds starting from
 current time. In the latter case, this number of seconds may not exceed
 60*60*24*30 (number of seconds in 30 days); if the number sent by a client
 is larger than that, the server will consider it to be real Unix time value
 rather than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#replace(java.lang.String, int, java.lang.Object)">replace</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGet</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/GetFuture.html" title="class in net.spy.memcached.internal">GetFuture</A>&lt;T&gt; <B>asyncGet</B>(java.lang.String&nbsp;key,
                                 <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the given key asynchronously.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGet</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGet(java.lang.String)"><!-- --></A><H3>
asyncGet</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/GetFuture.html" title="class in net.spy.memcached.internal">GetFuture</A>&lt;java.lang.Object&gt; <B>asyncGet</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Get the given key asynchronously and decode with the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGet(java.lang.String)">asyncGet</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGets</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt; <B>asyncGets</B>(java.lang.String&nbsp;key,
                                                  <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Gets (with CAS support) the given key asynchronously.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGets(java.lang.String)"><!-- --></A><H3>
asyncGets</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt; <B>asyncGets</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Gets (with CAS support) the given key asynchronously and decode using the
 default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGets(java.lang.String)">asyncGets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
gets</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt; <B>gets</B>(java.lang.String&nbsp;key,
                            <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Gets (with CAS support) with a single key.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">gets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>the result from the cache and CAS id (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
getAndTouch</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt; <B>getAndTouch</B>(java.lang.String&nbsp;key,
                                   int&nbsp;exp,
                                   <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get with a single key and reset its expiration.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">getAndTouch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>exp</CODE> - the new expiration for the key<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>the result from the cache (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getAndTouch(java.lang.String, int)"><!-- --></A><H3>
getAndTouch</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt; <B>getAndTouch</B>(java.lang.String&nbsp;key,
                                              int&nbsp;exp)</PRE>
<DL>
<DD>Get a single key and reset its expiration using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getAndTouch(java.lang.String, int)">getAndTouch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>exp</CODE> - the new expiration for the key
<DT><B>Returns:</B><DD>the result from the cache and CAS id (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="gets(java.lang.String)"><!-- --></A><H3>
gets</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt; <B>gets</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Gets (with CAS support) with a single key using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#gets(java.lang.String)">gets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get
<DT><B>Returns:</B><DD>the result from the cache and CAS id (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
get</H3>
<PRE>
public &lt;T&gt; T <B>get</B>(java.lang.String&nbsp;key,
                 <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get with a single key.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#get(java.lang.String, net.spy.memcached.transcoders.Transcoder)">get</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>the result from the cache (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.Object <B>get</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Get with a single key and decode using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#get(java.lang.String)">get</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get
<DT><B>Returns:</B><DD>the result from the cache (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Iterator, java.util.Iterator)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
                                                                      java.util.Iterator&lt;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&gt;&nbsp;tcIter)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Iterator, java.util.Iterator)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keyIter</CODE> - Iterator that produces keys.<DD><CODE>tcIter</CODE> - an iterator of transcoders to serialize and unserialize
          values; the transcoders are matched with the keys in the same
          order. The minimum of the key collection length and number of
          transcoders is used and no exception is thrown if they do not
          match
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Collection, java.util.Iterator)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
                                                                      java.util.Iterator&lt;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&gt;&nbsp;tcIter)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Collection, java.util.Iterator)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys to request<DD><CODE>tcIter</CODE> - an iterator of transcoders to serialize and unserialize
          values; the transcoders are matched with the keys in the same
          order. The minimum of the key collection length and number of
          transcoders is used and no exception is thrown if they do not
          match
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
                                                                      <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keyIter</CODE> - Iterator for the keys to request<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize values
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
                                                                      <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys to request<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize values
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Iterator)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt; <B>asyncGetBulk</B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache and decode them with
 the given transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Iterator)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keyIter</CODE> - Iterator that produces the keys to request
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Collection)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt; <B>asyncGetBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache and decode them with
 the given transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Collection)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys to request
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
                                                                      java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Varargs wrapper for asynchronous bulk gets.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value<DD><CODE>keys</CODE> - one more more keys to get
<DT><B>Returns:</B><DD>the future values of those keys
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.lang.String...)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/BulkFuture.html" title="interface in net.spy.memcached.internal">BulkFuture</A>&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt; <B>asyncGetBulk</B>(java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Varargs wrapper for asynchronous bulk gets with the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.lang.String...)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - one more more keys to get
<DT><B>Returns:</B><DD>the future values of those keys
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetAndTouch(java.lang.String, int)"><!-- --></A><H3>
asyncGetAndTouch</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt; <B>asyncGetAndTouch</B>(java.lang.String&nbsp;key,
                                                                    int&nbsp;exp)</PRE>
<DL>
<DD>Get the given key to reset its expiration time.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetAndTouch(java.lang.String, int)">asyncGetAndTouch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>exp</CODE> - the new expiration to set for the given key
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGetAndTouch</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt; <B>asyncGetAndTouch</B>(java.lang.String&nbsp;key,
                                                         int&nbsp;exp,
                                                         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the given key to reset its expiration time.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetAndTouch(java.lang.String, int, net.spy.memcached.transcoders.Transcoder)">asyncGetAndTouch</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>exp</CODE> - the new expiration to set for the given key<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public &lt;T&gt; java.util.Map&lt;java.lang.String,T&gt; <B>getBulk</B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter,
                                                     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Iterator, net.spy.memcached.transcoders.Transcoder)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keyIter</CODE> - Iterator that produces the keys<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Iterator)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object&gt; <B>getBulk</B>(java.util.Iterator&lt;java.lang.String&gt;&nbsp;keyIter)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Iterator)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keyIter</CODE> - Iterator that produces the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public &lt;T&gt; java.util.Map&lt;java.lang.String,T&gt; <B>getBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
                                                     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Collection)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object&gt; <B>getBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Collection)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public &lt;T&gt; java.util.Map&lt;java.lang.String,T&gt; <B>getBulk</B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
                                                     java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - <DT><B>Parameters:</B><DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value<DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.lang.String...)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object&gt; <B>getBulk</B>(java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.lang.String...)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getVersions()"><!-- --></A><H3>
getVersions</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.lang.String&gt; <B>getVersions</B>()</PRE>
<DL>
<DD>Get the versions of all of the connected memcacheds.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getVersions()">getVersions</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a Map of SocketAddress to String for connected servers
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getStats()"><!-- --></A><H3>
getStats</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; <B>getStats</B>()</PRE>
<DL>
<DD>Get all of the stats from all of the connections.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getStats()">getStats</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a Map of a Map of stats replies by SocketAddress
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getStats(java.lang.String)"><!-- --></A><H3>
getStats</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; <B>getStats</B>(java.lang.String&nbsp;arg)</PRE>
<DL>
<DD>Get a set of stats from all connections.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getStats(java.lang.String)">getStats</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - which stats to get
<DT><B>Returns:</B><DD>a Map of the server SocketAddress to a map of String stat keys to
         String stat values.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, long)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by)</PRE>
<DL>
<DD>Increment the given key by the given amount.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, long)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by)</PRE>
<DL>
<DD>Increment the given key by the given amount.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, long)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by)</PRE>
<DL>
<DD>Decrement the given key by the given value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, long)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the value
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by)</PRE>
<DL>
<DD>Decrement the given key by the given value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the value
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, long, long, int)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, long, long, int)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int, long, int)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int, long, int)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, long, long, int)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, long, long, int)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int, long, int)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.

 Due to the way the memcached server operates on items, incremented and
 decremented items will be returned as Strings with any operations that
 return a value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int, long, int)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncIncr(java.lang.String, long)"><!-- --></A><H3>
asyncIncr</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt; <B>asyncIncr</B>(java.lang.String&nbsp;key,
                                                 long&nbsp;by)</PRE>
<DL>
<DD>Asychronous increment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncIncr(java.lang.String, long)">asyncIncr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key to increment<DD><CODE>by</CODE> - the amount to increment the value by
<DT><B>Returns:</B><DD>a future with the incremented value, or -1 if the increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncIncr(java.lang.String, int)"><!-- --></A><H3>
asyncIncr</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt; <B>asyncIncr</B>(java.lang.String&nbsp;key,
                                                 int&nbsp;by)</PRE>
<DL>
<DD>Asychronous increment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncIncr(java.lang.String, int)">asyncIncr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key to increment<DD><CODE>by</CODE> - the amount to increment the value by
<DT><B>Returns:</B><DD>a future with the incremented value, or -1 if the increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncDecr(java.lang.String, long)"><!-- --></A><H3>
asyncDecr</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt; <B>asyncDecr</B>(java.lang.String&nbsp;key,
                                                 long&nbsp;by)</PRE>
<DL>
<DD>Asynchronous decrement.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncDecr(java.lang.String, long)">asyncDecr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key to increment<DD><CODE>by</CODE> - the amount to increment the value by
<DT><B>Returns:</B><DD>a future with the decremented value, or -1 if the increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncDecr(java.lang.String, int)"><!-- --></A><H3>
asyncDecr</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Long&gt; <B>asyncDecr</B>(java.lang.String&nbsp;key,
                                                 int&nbsp;by)</PRE>
<DL>
<DD>Asynchronous decrement.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncDecr(java.lang.String, int)">asyncDecr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key to increment<DD><CODE>by</CODE> - the amount to increment the value by
<DT><B>Returns:</B><DD>a future with the decremented value, or -1 if the increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, long, long)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, long, long)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int, long)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int, long)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, long, long)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 long&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, long, long)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int, long)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int, long)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
           exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="delete(java.lang.String, int)"><!-- --></A><H3>
delete</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>delete</B>(java.lang.String&nbsp;key,
                                                            int&nbsp;hold)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Hold values are no longer honored.</I>
<P>
<DD>Delete the given key from the cache.

 <p>
 The hold argument specifies the amount of time in seconds (or Unix time
 until which) the client wishes the server to refuse "add" and "replace"
 commands with this key. For this amount of item, the item is put into a
 delete queue, which means that it won't possible to retrieve it by the
 "get" command, but "add" and "replace" command with this key will also fail
 (the "set" command will succeed, however). After the time passes, the item
 is finally deleted from server memory.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to delete<DD><CODE>hold</CODE> - how long the key should be unavailable to add commands
<DT><B>Returns:</B><DD>whether or not the operation was performed</DL>
</DD>
</DL>
<HR>

<A NAME="delete(java.lang.String)"><!-- --></A><H3>
delete</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>delete</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Delete the given key from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#delete(java.lang.String)">delete</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to delete
<DT><B>Returns:</B><DD>whether or not the operation was performed
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="flush(int)"><!-- --></A><H3>
flush</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>flush</B>(int&nbsp;delay)</PRE>
<DL>
<DD>Flush all caches from all servers with a delay of application.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#flush(int)">flush</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the period of time to delay, in seconds
<DT><B>Returns:</B><DD>whether or not the operation was accepted
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A><H3>
flush</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/internal/OperationFuture.html" title="class in net.spy.memcached.internal">OperationFuture</A>&lt;java.lang.Boolean&gt; <B>flush</B>()</PRE>
<DL>
<DD>Flush all caches from all servers immediately.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#flush()">flush</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>whether or not the operation was performed
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="listSaslMechanisms()"><!-- --></A><H3>
listSaslMechanisms</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>listSaslMechanisms</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#listSaslMechanisms()">MemcachedClientIF</A></CODE></B></DD>
<DD>Get the set of SASL mechanisms supported by the servers.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#listSaslMechanisms()">listSaslMechanisms</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the union of all SASL mechanisms supported by the servers.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>Shut down immediately.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#shutdown()">shutdown</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
shutdown</H3>
<PRE>
public boolean <B>shutdown</B>(long&nbsp;timeout,
                        java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Shut down this client gracefully.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#shutdown(long, java.util.concurrent.TimeUnit)">shutdown</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the amount of time time for shutdown<DD><CODE>unit</CODE> - the TimeUnit for the timeout
<DT><B>Returns:</B><DD>result of the shutdown request</DL>
</DD>
</DL>
<HR>

<A NAME="waitForQueues(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
waitForQueues</H3>
<PRE>
public boolean <B>waitForQueues</B>(long&nbsp;timeout,
                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Wait for the queues to die down.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#waitForQueues(long, java.util.concurrent.TimeUnit)">waitForQueues</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the amount of time time for shutdown<DD><CODE>unit</CODE> - the TimeUnit for the timeout
<DT><B>Returns:</B><DD>result of the request for the wait
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue is too
           full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="addObserver(net.spy.memcached.ConnectionObserver)"><!-- --></A><H3>
addObserver</H3>
<PRE>
public boolean <B>addObserver</B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</PRE>
<DL>
<DD>Add a connection observer.

 If connections are already established, your observer will be called with
 the address and -1.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#addObserver(net.spy.memcached.ConnectionObserver)">addObserver</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obs</CODE> - the ConnectionObserver you wish to add
<DT><B>Returns:</B><DD>true if the observer was added.</DL>
</DD>
</DL>
<HR>

<A NAME="removeObserver(net.spy.memcached.ConnectionObserver)"><!-- --></A><H3>
removeObserver</H3>
<PRE>
public boolean <B>removeObserver</B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</PRE>
<DL>
<DD>Remove a connection observer.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#removeObserver(net.spy.memcached.ConnectionObserver)">removeObserver</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obs</CODE> - the ConnectionObserver you wish to add
<DT><B>Returns:</B><DD>true if the observer existed, but no longer does</DL>
</DD>
</DL>
<HR>

<A NAME="connectionEstablished(java.net.SocketAddress, int)"><!-- --></A><H3>
connectionEstablished</H3>
<PRE>
public void <B>connectionEstablished</B>(java.net.SocketAddress&nbsp;sa,
                                  int&nbsp;reconnectCount)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html#connectionEstablished(java.net.SocketAddress, int)">ConnectionObserver</A></CODE></B></DD>
<DD>A connection has just successfully been established on the given socket.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html#connectionEstablished(java.net.SocketAddress, int)">connectionEstablished</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sa</CODE> - the address of the node whose connection was established<DD><CODE>reconnectCount</CODE> - the number of attempts before the connection was
          established</DL>
</DD>
</DL>
<HR>

<A NAME="connectionLost(java.net.SocketAddress)"><!-- --></A><H3>
connectionLost</H3>
<PRE>
public void <B>connectionLost</B>(java.net.SocketAddress&nbsp;sa)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html#connectionLost(java.net.SocketAddress)">ConnectionObserver</A></CODE></B></DD>
<DD>A connection was just lost on the given socket.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html#connectionLost(java.net.SocketAddress)">connectionLost</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sa</CODE> - the address of the node whose connection was lost</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MemcachedClient.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/spy/memcached/KeyUtil.html" title="class in net.spy.memcached"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/spy/memcached/MemcachedClient.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MemcachedClient.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Copyright &copy; 2006-2009 Dustin Sallings, 2009-2012 Couchbase, Inc.
</BODY>
</HTML>
